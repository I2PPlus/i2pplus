const MAX_CONCURRENT_REQUESTS=16,MAX_QUEUE_SIZE=16,MIN_INTERVAL=500,DEBOUNCE_DELAY=200,responseCountMap=new Map,clientId=Math.random().toString(36).substr(2,9);let activeRequests=0,fetchQueue=[],noResponse=0,debounceTimeouts=new Map;function handleClientMessage(event,clientData){const{url,force=!1}=event.data,now=Date.now();event=responseCountMap.get(clientId)?.lastRequestTime||0,!force&&now-event<MIN_INTERVAL||fetchQueue.length>=MAX_QUEUE_SIZE||(force?enqueueFetchRequest(url,now,clientData):debounceTimeouts.has(url)&&clearTimeout(debounceTimeouts.get(url)),debounceTimeouts.set(url,setTimeout(()=>{enqueueFetchRequest(url,now,clientData),debounceTimeouts.delete(url)},DEBOUNCE_DELAY)))}function enqueueFetchRequest(url,now,clientData){activeRequests<MAX_CONCURRENT_REQUESTS?(activeRequests++,processFetchRequest(url,now,clientData)):fetchQueue.push({url:url,now:now,clientData:clientData})}async function processFetchRequest(url,now,clientData){var{port:clientData,clientId}=clientData;try{var contentType,response=await fetch(url);let messagePayload;response.ok?(contentType=response.headers.get("Content-Type"),messagePayload=contentType&&contentType.includes("text/html")?{url:url,responseText:await response.text(),isDown:!1,noResponse:0}:{url:url,responseBlob:await response.blob(),isDown:!1,noResponse:0},updateLastRequestTime(clientId,now)):messagePayload={url:url,isDown:!0,noResponse:incrementNoResponse()},clientData.postMessage(messagePayload)}catch(error){clientData.postMessage({url:url,isDown:!0,noResponse:incrementNoResponse()})}finally{decrementActiveRequests(),processNextFetchRequest()}}function updateLastRequestTime(clientId,now){responseCountMap.set(clientId,{lastRequestTime:now})}function incrementNoResponse(){return++noResponse}function decrementActiveRequests(){activeRequests--}function processNextFetchRequest(){for(;activeRequests<MAX_CONCURRENT_REQUESTS&&0<fetchQueue.length;){var{url,now,clientData}=fetchQueue.shift();activeRequests++,processFetchRequest(url,now,clientData)}}function cleanupClient(clientId){responseCountMap.delete(clientId),fetchQueue=fetchQueue.filter(item=>item.clientData.clientId!==clientId)}self.onconnect=function(e){const clientData={port:e=e.ports[0],clientId:clientId};e.onmessage=function(event){handleClientMessage(event,clientData)},e.onclose=()=>{cleanupClient(clientId)}};