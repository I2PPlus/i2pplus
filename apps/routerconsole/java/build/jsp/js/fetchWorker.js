const MAX_CONCURRENT_REQUESTS=32,MIN_INTERVAL=500;let activeRequests=0,fetchQueue=[];const lastRequestTimeMap=new Map;async function processFetchRequest(url){var now=Date.now();try{var responseText,responseBlob,response=await fetch(url,{method:"GET",headers:{Accept:"text/html, application/octet-stream"}});response.ok?response.headers.get("Content-Type").includes("text/html")?(responseText=await response.text(),self.postMessage({responseText:responseText,isDown:!1})):(responseBlob=await response.blob(),self.postMessage({responseBlob:responseBlob,isDown:!1})):self.postMessage({responseBlob:null,isDown:!0})}catch(error){console.error("Error:",error),setTimeout(()=>{self.postMessage({responseBlob:null,isDown:!0})},3e3)}finally{activeRequests--,processNextFetchRequest(),lastRequestTimeMap.set(url,now)}}function processNextFetchRequest(){var url;0<fetchQueue.length&&activeRequests<MAX_CONCURRENT_REQUESTS&&(url=fetchQueue.shift(),activeRequests++,processFetchRequest(url))}self.addEventListener("message",async function(event){var{url:event,force=!1}=event.data,now=Date.now(),lastRequestTime=lastRequestTimeMap.get(event);!force&&void 0!==lastRequestTime&&now-lastRequestTime<MIN_INTERVAL?console.log("Skipping request for URL:",event):activeRequests<MAX_CONCURRENT_REQUESTS?(activeRequests++,processFetchRequest(event)):fetchQueue.push(event)});